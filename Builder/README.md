# 建造者模式
创建者模式又叫建造者模式，是将一个复杂的对象的构建与它的表示分离，使
得同样的构建过程可以创建不同的表示。创建者模式隐藏了复杂对象的创建过程，它把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态的创建具有复合属性的对象。

## 优点和缺点
### 优点：
1.封装性好，构建和表示分离。
2.扩展性好，各个具体的建造者相互独立，有利于系统的解耦。
3.客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。
### 缺点：
1.产品的组成部分必须相同，这限制了其使用范围。
2.如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。
### 应用场景
1.隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果.  
2.多个部件都可以装配到一个对象中，但产生的运行结果不相同.  
3.产品类非常复杂或者产品类因为调用顺序不同而产生不同作用.  
4.初始化一个对象时，参数过多，或者很多参数具有默认值.  
5.Builder模式不适合创建差异性很大的产品类产品内部变化复杂，会导致需要定义很多具体建造者类实现变化，增加项目中类的数量，增加系统的理解难度和运行成本.  
6.需要生成的产品对象有复杂的内部结构，这些产品对象具备共性.

## 例子

如果你有使用过orm，那你一定不陌生。如果你对orm还不清楚，那我举一个例子你就清楚了。  

```
select * from user where user_id = 1;
```  

如果让你使用go来封装实现你会怎么做?  

### 一个数据库对象  

```go
// 建立一个db对象
type DB struct {
	Table  interface{}
	Filter []string
}
```  

### new  

```go 
// 先创建一个db对象
func NewOrm() *DB {
	return &DB{}
}
```  

### 相关语句

```go
// table 相关
func (d *DB) QueryTable(i interface{}) *DB {
	d.Table = i
	return d
}

// where 语句
func (d *DB) Where(field string, v interface{}) *DB {
	s := fmt.Sprintf("%s %v", field, v)
	d.Filter = append(d.Filter, s)
	return d
}

// 查询all
func (d *DB) All() *DB {
	return d
}

```   

### 效果

```go
o := NewOrm()
o.QueryTable("user").Where("user_id = ", 1).All()
```

这里并没有对里面的逻辑进行编写，真实的orm并不是这样的。但是我们要理解的是orm采用了建造者模式。